# Virtual

## 虚函数与运行多态

参考代码：emp.cpp

**虚函数的调用取决于指向或者引用的对象类型，而不是指针或者引用自身的类型**。



## 虚函数中默认参数

参考代码：defaultArg.cpp

**默认参数是静态绑定的，虚函数是动态绑定的。默认参数的使用需要看指针或者引用本身的类型，而不是对象的类型。**



## 可以不可以

###### （1）静态函数可以声明为虚函数吗？

静态函数不可以声明为虚函数，同时也不能被`const`和`volatile`关键字修饰。

`static`成员函数不属于任何对象或类实例，所以即使给函数加上`virtual`也没有意义。

虚函数依靠`vptr`和`vtable`来处理。`vptr`是一个指针，在类的构造函数中创建完成，并且只能用`this`指针来访问它，静态成员函数没有`this`指针，所以无法访问`vptr`。

###### （2）构造函数可以为虚函数吗？

不可以。

同时除了`inline | explicit`之外，构造函数不允许使用其他任何关键字。

尽管虚函数表是在编译阶段就已经建立起来，但指向虚寒是表的指针是在运行阶段实例化对象才产生的。如果类含有虚函数，编译器会在构造函数中添加代码来创建虚指针。



###### （3）析构函数可以为虚函数吗？

析构函数可以声明为虚函数。如果我们需要删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。事实上，只要一个类有可能会被其他类所继承，就应该声明虚析构函数。

代码学习：fullVirde.cpp



###### (4) 虚函数可以被内联吗？

通常成员函数都会被编译器考虑是否进行内联。但通过基类指针或者引用调用的函数必定不能被内联。当然，实体对象调用虚函数或者静态调用时可以被内联，虚析构函数的静态调用也一定会被内联展开。

- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
- 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码。因此虚函数表现为多态性时（运行期）不可以内联。
- `inline virtual`唯一可以内联的时候是：编译器知所调用的是哪个类。



## RTTI与dynamic_cast

RTTI(Run-Time Type Identification)，通过运行时类型信息程序能够使用基类的指针或引用来检查这些指针或引用所指的实际派生类类型。

在面向对象程序中，有时我们需要在运行时查询一个对象是否能作为某种多态类型使用。与Java的instanceof以及C#的as,is运算符类似。

C++提供了dynamic_cast函数用于动态转型。