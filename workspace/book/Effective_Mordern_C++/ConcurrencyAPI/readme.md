# 并发API

# 条款35，优先选用基于任务而非给予线程的程序设计

如果你想以异步方式运行函数`doAsynWork`，有两种基本选择。你可以创建一个`std::thread`，并在其上运行`doAsynWork`，所以这是基于线程的途径：

```c++
int doAsnyWork();

std::thread t(doAsnyWork);
```



或者，把任务传递给`std::async`，这叫做基于任务

```c++
auto fut = std::async(doAsynWork);
```



基于线程和基于任务的程序设计之间更基本的区别在于，基于任务的程序设计表现着更高阶的抽象。

线程在带有并发C++软件中的三种意义：

- 硬件线程是实际执行计算的线程。现代计算机体系结构会为每个CPU内核提供一个或多个硬件线程。
- 软件线程是操作系统用以实施跨进程的管理，以及进行硬件线程调度的线程。通常，能够创建的软件线程会比硬件线程要多，因为当一个软件线程阻塞了，运行另外的非阻塞线程能够提升吞吐率。
- `std::thread`是C++进程里的对象，用作底层软件线程的句柄。有些`std::thread`对象表示为`null`句柄，对应于**无软件线程**，可能的原因有：他们处于默认构造状态，或者被移动了，或者被联结了，或者被分离了。

软件线程是一种有限的资源，当你试图创建的线程数量多于系统能够提供的数量，就会抛出`std::system_error`异常。即使加上了`noexcept`。

通过使用`std::async`来解决这个问题。



但是仍有几种情况，直接使用线程会更合适：

- **你需要访问底层线程实现的API**，C++并发API通常会采用特定平台的低级API来实现，经常使用的有`pthread`和Windows线程库。它们提供的API比C++提供的更丰富。
- **你需要且有能力为你的应用优化线程用法**。
- **你需要实现超越C++并发API的线程技术**。



###### 总结

- `std::thread`的API未提供直接获取异步运行函数返回值的途径，而且如果那些函数抛出异常，程序就会终止。
- 基于线程的程序设计要求手动管理线程耗尽、超订、负载均衡、以及新平台适配。
- 经由应用了默认启动策略的`std::async`进行基于任务的程序设计，大部分这类问题都能找到解决之道。



# 条款36，如果异步是必要的，则指定std::launch::async

假设函数`f`要传递给`std::async`执行：

- `std::launch::async`启动策略意味着函数`f`必须以异步方式进行，亦即，在另一个线程上执行。
- `std::launch::deferred`启动策略意味着函数`f`只会在`std::async`所返回值的`get`或`wait`得到调用时才运行。执行会推迟至其中一个调用发生的时刻，当调用`get`或`wait`时，`f`会同步运行。即，调用方会阻塞至`f`运行结束为止。如果`get`或`wait`都没有得到调用，`f`是不会运行的。

```c++
//下面两端代码意义相同
auto fut1 = std::async(f);

auto fut2 = std::async(std::launch::async | std::launch::deferred, f);
```



> 默认启动策略就允许`f`以异步或同步的方式运行皆可。
>
> 但是使用默认策略会存在一些问题：
>
> - 无法预知`f`是否会和`t`并发运行，因为`f`可能会被推迟运行。
> - 无法预知`f`是否运行在与调用`fut`的`get`或`wait`函数的线程不同的某线程上。如果那个线程是`t`，那就是说无法预知`f`是否会运行在与`t`不同的某线程上。
> - 连`f`是否会运行这件事都是无法预知的，这是因为无法保证在程序的每条路径上，`fut`的`get`和`wait`都会得到调用。



默认启动策略在调度上的弹性常会在使用`thread_local`变量时导致不明不白的混淆，这意味着如果`f`读或者写此线程级局部存储时，无法预知会取到的是哪个线程的局部存储，它也会影响那些基于`wait`的循环中以超时为条件者，因为对任务调用`wait_for`或者`wait_until`会产生`std::lanuch::deferred`值：

```c++
using namespace std::literals;

void f()		//f睡眠1s后返回
{
    std::this_thread:sleep_for(1s);
}

auto fut = std::async(f);			//存在问题的异步方式

while(fut.wait_for(100ms) != std::future_status::ready) {} //永远不可能结束循环

如果f是被推迟进行的，那么就永远都会返回std::future_status::deferred。;

auto fut = std::async(f);

if(fut.wait_for(0s) == std::future_status::deferred) {}//如果任务被推迟了，则使用异步方式
else {while(fut.wait_for(100ms) != std::future_status::ready) {}} //并发，直到任务就绪
```



综上，以默认启动策略对任务使用`std::async`能正常工作需要满足以下所有条件：

- 任务不需要与调用`get`或`wait`的线程并发执行。
- 读或者写哪个线程的`thread_local`并无影响。
- 或者可以给出保证`std::async`返回的期望值之上调用`get`和`wait`，或者可以接受任务可能用不执行。
- 使用`wait_for`或`wait_until`的代码将任务被推迟的可能性纳入考量。

###### 总结

- `std::async`的默认启动策略即允许任务以异步方式进行，也允许任务以同步方式进行。
- 如此弹性会导致使用`thread_local`变量时的不确定性，隐含着任务可能永不会执行，还会影响运用了基于超时的`wait`调用的程序逻辑。
- 如果异步是必要的，则指定`std::launch::async`

# 条款37，使std::thread型别对象在所有路径皆不可联结

###### 总结

- 使`std::thread`型别对象在所有路径皆不可联结。
- 在析构时调用`join`可能导致难以调试的性能异常。
- 在析构时调用`detach`可能导致难以调试的未定义行为。
- 在成员列表的最后声明`std::thread`型别对象。

# 条款38，对变化多端的句柄析构函数行为保持关注

###### 总结

- 期指的析构函数在常规情况下，仅会析构期值的成员变量。
- 指涉到经由`std::async`启动的未推迟任务的共享状态的最后一个期值会保持阻塞，直至该任务结束。

# 条款39，考虑针对一次性事件通信使用以void为模板型别实参的期值

###### 总结

- 如果为了实现平凡事件通信，基于条件变量的设计会要求多余的互斥量，这回给相互关联的检测和反应任务带来约束，并要求反应任务校验事件确已发生。
- 使用标志位的设计可以避免上述问题，但这一设计基于轮询而非阻塞。
- 条件变量和标志位可以一起使用，但这样的通信机制设计结果不甚自然。 
- 使用`std::promise`型别对象和期值就额可以回避这些问题，但是一来这个途径为了共享状态需要使用堆内存，而且仅限于一次性通信。

# 条款40，堆并发使用std::atomic，对特种内存使用volatile

- `std::atomic`用于多线程访问的数据，且不用互斥量。它是撰写并发软件的工具。
- `volatile`用于读写操作不可以被优化掉的内存。它是面对特种内存时使用的工具。



