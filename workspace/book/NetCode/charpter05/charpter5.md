# 基于TCP的服务端/客户端（2）

这章试图尝试修改上一章中代码存在的问题。

###### 问题不在服务器端，而在客户端

通过代码我们可以看到

```c++
//client
send(clientSocket,message,strlen(message), 0);
acceptLen = recv(clientSocket,message,BUFFSIZE - 1,0);



//server
while((acceptLen = recv(clntScocket,message,BUFFSIZE,0)) != 0)
	send(clntScocket,message,acceptLen,0);
```



问题就是，`recv`函数可能在没有收到全部数据时就调用了。

二者都在循环调用函数。实际上回声客户端将100%接收自己发送的数据，只不过接收的单位有些问题。

回声客户端传输的是字符串，而且是一次性发送的。之后还调用了一次`recv`函数，这就是问题所在。

既然回声客户端会收到所有字符串数据，那么过一段时间之后再调用`recv`函数就可以一次性读取所有字符串数据？



###### 如果问题不在客户端：定义应用层协议

收发数据过程中也需要定好规则以表示数据的边界，或提前告知收发数据的大小。

所以我们可以尝试做一个程序，客户端输入要求服务器计算的数据。

比如，可以提前定义好待输入的数据，然后输入需要进行运算的操作符。



###### TCP套接字中的I/O缓冲

实际上，`send`函数调用后并非立即传输数据，而是将数据移出输出缓冲。`recv`调用书瞬间，从输入缓冲读取数据。

- IO缓冲在每个TCP套接字中单独存在。
- IO缓冲在创建套接字时自动生成。
- 即使关闭套接字也会继续传递输出缓冲中遗留的数据。
- 关闭套接字将丢失输入缓冲中的数据。

