# 设计与声明

## 让接口容易被正确使用，不易被误用

**考虑用户做出什么样的错误**

假设设计一个用来表示日期的类：

```c++
class Date
{
    public:
    	Data(int month, int day, int year);
    	...;
};

//这个接口看起来可能没什么问题，但是用户可能传递的是
Date d(30,3,1995); //应该是3，30
Date d(2,30,1995); //用户打错，是3,30
```



许多客户端错误可以因为导入新类型而获得预防。我们可以导入简单的外覆类型来区别天数、月份和年份

```c++
struct Day{
    explicit Day(int d) : val(d) {}
    int val;
};

struct Month{
    explicit Month(int m) : val(m) {}
    int val;
};

struct Year{
    explicit Year(int y) : val(y) {}
    int val;
};

class Date{
    public:
    	Date(const Month & m, const Day & d, const Year & y);
    	...;
};

Date(30,3,1995);						//错误，不正确的类型
Date(Month(30),Month(3),Year(1995));	//错误，不正确的类型
Date(Month(3),Day(30),Year(1995));		//类型正确
```



一旦正确的类型就定位，限制其值有时候是同情达理的。假如一年只有12个月，所以Month应该反映这一事实。

我们可以使用`enum`，但是其安全性不够。

```c++
class Month
{
    public:
    	static Month Jan() {return Month(1);}
   		static Month Feb() {return Month(2);}
    	...;   	
    	static Month Dec() {return Month(12);}
    	...; 			//other
    private:
    	explicit Month(int m);		//阻止生成新的月份；
    	...;						//月份专属数据 
};

Date d(Month::Mar(), Day(30),Year(1995));
```



预防客户错误的另一个方法是，限制类型什么事可以做，什么事不能做。比较常用的方法是加上`const`。



任何接口如果要求客户必须记得做某些事情，就是有着**不正确使用**的倾向，因为客户可能会忘记做那件事。



==好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质==

==促进正确使用   的办法包括接口的一致性，以及内置类型的行为兼容==

==阻止误用  的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任==

==tr1::shared_ptr支持定制型删除器。这可以防范DLL问题，可被用来自动解除互斥锁==



## 设计CLASS犹如设计TYPE

当你定义了一个`class`，也就是定义了一个`type`。

如何设计高效的`class`，请回答下面的问题：

- **新type的对象应该如何被创建和销毁？**这会影响到你的`class`的构造函数和析构函数以及内存分配函数和释放函数（`operatornew, operatornew[],operator delete,operator[]`）的设计。
- **对象的初始化和对象的赋值该有什么差别？**这个答案决定了你构造函数和赋值操作符的行为，以及其间的差异。很重要的是别混淆了**初始化**和**赋值**，因为它们对应于不同的函数调用。
- **新type的对象如果被passed by valued，意味着什么？**记住，copy构造函数用来定义一个`type`的`pass-by-value`该如何实现？
- **什么是新type的合法值？**对`class`的成员变量而言，通常只有某些数值是有效的。那些数值集决定了你的`class`必须维护的约束条件。也就决定了你的成员函数必须进行的错误检查工作。它也影响函数抛出的异常、以及函数异常明细列。
- **你的新type需要配合某个继承图系吗？**如果你继承自某些既有的`classes`，你就受到那些`classes`的设计的束缚，特别是受到虚函数和非虚函数的影响。如果你允许其他类继承你的类，那会影响你声明函数——尤其是析构函数，是否为`virtual`。
- **你的新type需要什么样的转换？**你的type生存于其他海票type之间，因此彼此应该又转换行为吗？如果你希望允许类型T1之物被隐式转换T2之物，就必须在T1内写一个类型转换函数或在T2内写一个构造函数。
- **什么样的操作符和函数对此新type而言是合理的？**其中某些该是成员函数，其中某些应该不是。
- **什么样的标准函数应该驳回？**声明为`private`。
- **谁该取用新type的成员？**思考什么为`public,private,protected`以及是否为友元。
- **什么是新type的未声明接口？**它对效率、异常安全性以及资源运用提供何种保证？你在这些方面提供的保证将为你的类实现代码上加上相应的约束条件。
- **你的新type有多么一般化？**模板类。
- **你真的需要一个新type吗？**如果只是定义新的继承类以便为既有的类添加机能，那么说不定单纯定义一个或多个非成员函数和模板更能达到目标。

